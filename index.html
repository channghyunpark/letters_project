<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Multi‑Mode Typing Layout — Continue-on-Grid + Zoom/Pan</title>
<style>
  :root { --bg:#fff; --fg:#111; --muted:#666; --anim-ms:800; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,Helvetica,Arial,Apple SD Gothic Neo,"Malgun Gothic",sans-serif}
  .wrap{display:grid;grid-template-rows:auto 1fr auto;min-height:100dvh}
  header{display:flex;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid #eaeaea}
  .modes{display:flex;gap:6px;flex-wrap:wrap}
  .mode{appearance:none;border:1px solid #e5e5e5;background:#fff;color:var(--fg);padding:8px 10px;border-radius:10px;font-size:13px;cursor:pointer}
  .mode.active{background:#111;color:#fff;border-color:#111}
  .stage{position:relative;overflow:hidden;isolation:isolate;height:60vh;margin:12px 16px;border:1px solid #eee;border-radius:14px;background:#fff}
  .content{position:absolute;inset:0;transform-origin:0 0}
  .glyph{position:absolute;left:0;top:0;transform:translate3d(0,0,0);transition:transform var(--anim-ms) cubic-bezier(.22,.61,.36,1),opacity var(--anim-ms) ease;will-change:transform;font-size:18px;line-height:1;color:#111;user-select:none;white-space:pre}
  .panel{display:grid;grid-template-columns:1fr 320px;gap:16px;padding:0 16px 16px}
  textarea{width:100%;min-height:130px;resize:vertical;padding:12px;border:1px solid #eaeaea;border-radius:10px;font-size:14px;color:var(--fg);background:#fff;outline:none}
  .help{font-size:12px;color:var(--muted)}
  .footer{display:flex;align-items:center;justify-content:space-between;padding:12px 16px 16px;font-size:12px;color:var(--muted)}
  /* Zoom UI */
  .zoomDock{position:absolute;right:10px;bottom:10px;display:flex;gap:6px;background:rgba(255,255,255,.85);border:1px solid #eee;border-radius:10px;padding:6px;backdrop-filter:saturate(1.2) blur(2px)}
  .zbtn{appearance:none;border:1px solid #ddd;background:#fff;color:#111;font-size:12px;padding:6px 8px;border-radius:8px;cursor:pointer}
  .zbtn:hover{border-color:#bbb}
  .stage.panning{cursor:grab}
  .stage.panning.dragging{cursor:grabbing}
  /* Toast */
  .toast{position:fixed;left:50%;bottom:22px;transform:translateX(-50%);background:#111;color:#fff;padding:8px 12px;border-radius:10px;font-size:12px;opacity:0;pointer-events:none;transition:opacity .25s ease}
  .toast.show{opacity:.9}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="title">Multi‑Mode Typing Layout</div>
    <div class="modes" id="modeBar">
      <button class="mode active" data-mode="normal">Normal</button>
      <button class="mode" data-mode="circle">Circle</button>
      <button class="mode" data-mode="spiral">Spiral</button>
      <button class="mode" data-mode="wave">Wave</button>
      <button class="mode" data-mode="tree">Tree</button>
    </div>
  </header>

  <div class="stage" id="stage" aria-label="렌더 스테이지">
    <div id="content" class="content"></div>
    <div class="zoomDock">
      <button class="zbtn" data-zoom="out" title="Zoom out">−</button>
      <button class="zbtn" data-zoom="reset" title="Reset to 100%">100%</button>
      <button class="zbtn" data-zoom="in" title="Zoom in">+</button>
      <button class="zbtn" data-zoom="fit" title="Fit to view">Fit</button>
    </div>
  </div>
  <div class="toast" id="toast" hidden></div>

  <section class="panel">
    <div>
      <textarea id="input" placeholder="여기에 타이핑하고, 중간에 모드를 바꾸면 그 지점부터 새 그리드로 이어서 작성됩니다."></textarea>
      <div class="help">휠로 줌, <b>Space+드래그</b>로 이동, 오른쪽 아래 버튼으로 +/−/리셋/Fit</div>
    </div>
    <div class="help">
      <p><strong>모드</strong> — Normal / Circle / Spiral / Wave / Tree</p>
      <p>Tree는 레벨이 깊어질수록 좌우 폭이 커지고 <em>결정론적</em> jitter로 자연스럽게 퍼집니다.</p>
    </div>
  </section>

  <div class="footer"><span>⌨️ 계속 타이핑 → 임의 시점에 모드 전환 → 이어서 작성</span><span>v0.4</span></div>
</div>

<script>
(() => {
  const stage = document.getElementById('stage');
  const content = document.getElementById('content');
  const zoomDock = stage.querySelector('.zoomDock');
  const input = document.getElementById('input');
  const modeBar = document.getElementById('modeBar');
  const toast = document.getElementById('toast');

  // ===== State =====
  let mode = 'normal';
  let glyphs = [];            // placed glyphs {el,ch,x,y,z}
  let prevText = '';
  const pen = { x:0, y:0, z:0, i:0, mode:'normal', anchorX:0, anchorY:0, anchorZ:0 };

  function stageRect(){ return stage.getBoundingClientRect(); }
  function initPen(){ const r=stageRect(); pen.x=r.width/2; pen.y=r.height/2; pen.z=0; pen.anchorX=pen.x; pen.anchorY=pen.y; pen.anchorZ=pen.z; pen.i=0; }

  // ===== Deterministic jitter (for Tree) =====
  function hash32(x){ let t=x+0x6D2B79F5; t=Math.imul(t ^ (t>>>15), t|1); t^= t + Math.imul(t ^ (t>>>7), t | 61); return ((t ^ (t>>>14))>>>0)/4294967296; }
  function jitter(i, salt){ return hash32(i*73856093 + salt*19349663) - 0.5; }

  // ===== Paths (relative to anchor) =====
  const stepSize = 16;
  const NORMAL_COLS = 60; // 고정 열 수로 Normal 모드 재배치 방지

  const Path = {
    normal(i){
      const cols = NORMAL_COLS; // 화면 폭에 의존하지 않음
      const row = Math.floor(i / cols);
      const col = i % cols;
      const stepX = 16, stepY = 24;
      return { dx: col*stepX, dy: row*stepY, dz: 0, rot: 0, scale: 1 };
    },
    circle(i){ const radius=120; const t=i*(Math.PI/16); return { dx:radius*Math.cos(t), dy:radius*Math.sin(t), dz:0, rot:t+Math.PI/2, scale:1 }; },
    spiral(i){ const b=0.10; const t=i*(Math.PI/10); const a=3; const r=a*Math.exp(b*t)*6; return { dx:r*Math.cos(t), dy:r*Math.sin(t), dz:0, rot:t+Math.PI/2, scale:1 }; },
    wave(i){ const A=60, lambda=140; const x=i*stepSize; const y=A*Math.sin((2*Math.PI/lambda)*x); return { dx:x, dy:y, dz:0, rot:0, scale:1 }; },
    tree(i){
      const level=Math.floor(Math.log2(i+1));
      const start=Math.pow(2,level)-1; const j=i-start; const count=Math.pow(2,level);
      const spread=(120+level*40); // wider per level
      const jx=jitter(i,1), jy=jitter(i,2);
      const x=((j+0.5)/count-0.5)*spread*2 + jx*level*8;
      const y=level*60 + jy*level*5;
      return { dx:x, dy:y, dz:0, rot:0, scale:1 };
    }
  };
  function getPath(name){ return Path[name] || Path.normal; }

  // ===== Caret =====
  const caret = document.createElement('div');
  caret.className = 'glyph'; caret.textContent = '▮'; caret.style.opacity = '0.5';
  content.appendChild(caret);
  function placeCaret(){ caret.style.transform = `translate3d(${pen.x}px, ${pen.y}px, ${pen.z}px)`; }

  // ===== Place/Remove glyphs =====
  function placeNextChar(ch){
    const p = getPath(pen.mode)(pen.i);
    const x = pen.anchorX + p.dx, y = pen.anchorY + p.dy, z = pen.anchorZ + p.dz;
    const el = document.createElement('div'); el.className = 'glyph';
    el.textContent = (ch === '\n') ? '⏎' : (ch === ' ' ? '·' : ch);
    const rotate = (pen.mode==='circle'||pen.mode==='spiral') ? ` rotate(${p.rot}rad)` : '';
    el.style.transform = `translate3d(${x}px, ${y}px, ${z}px)` + rotate;
    content.appendChild(el);
    glyphs.push({ el, ch, x, y, z });
    pen.x = x; pen.y = y; pen.z = z; pen.i += 1; placeCaret();
  }
  function backspaceOne(){
    if(!glyphs.length) return;
    const g = glyphs.pop(); g.el.remove();
    const last = glyphs[glyphs.length-1];
    if(last){ pen.x=last.x; pen.y=last.y; pen.z=last.z; } else { initPen(); }
    pen.i = Math.max(0, pen.i-1); placeCaret();
  }

  // ===== Strict append-only input handling =====
  const STRICT_APPEND = true; // 과거 글자 절대 고정
  let composing = false;
  input.addEventListener('compositionstart', () => composing = true);
  input.addEventListener('compositionend',  () => { composing = false; processInput(); });
  input.addEventListener('input',           () => { if (!composing) processInput(); });

  function showToast(msg){
    if (!toast) return;
    toast.textContent = msg;
    toast.hidden = false; toast.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>{ toast.classList.remove('show'); toast.hidden = true; }, 1200);
  }

  function processInput(){
    const cur = input.value;
    const selStart = input.selectionStart;
    const isTail = (selStart === cur.length);

    if (cur.startsWith(prevText)) {
      // tail append
      const appended = cur.slice(prevText.length);
      for (const ch of appended) placeNextChar(ch);
      prevText = cur; return;
    }

    if (prevText.startsWith(cur) && isTail) {
      // tail backspace
      const n = prevText.length - cur.length;
      for (let i=0;i<n;i++) backspaceOne();
      prevText = cur; return;
    }

    // non-tail edit
    if (STRICT_APPEND) {
      input.value = prevText; // 되돌림
      input.setSelectionRange(prevText.length, prevText.length);
      showToast('중간 편집은 이어쓰기 모드에서 허용되지 않습니다.');
      return;
    }

    // fallback: safe replay (deterministic positions)
    content.querySelectorAll('.glyph').forEach(n=>n.remove()); glyphs=[];
    initPen(); placeCaret();
    for (const ch of cur) placeNextChar(ch);
    prevText = cur;
  }

  // ===== Mode switch (past glyphs untouched) =====
  modeBar.addEventListener('click', (e) => {
    const b = e.target.closest('.mode'); if(!b) return;
    mode = b.dataset.mode;
    document.querySelectorAll('.mode').forEach(x=>x.classList.remove('active')); b.classList.add('active');
    pen.mode = mode; pen.anchorX = pen.x; pen.anchorY = pen.y; pen.anchorZ = pen.z; pen.i = 0; placeCaret();
  });

  // ===== Zoom & Pan =====
  let zoom=1, offsetX=0, offsetY=0; const minZoom=0.3, maxZoom=4;
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function applyView(){ content.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${zoom})`; }
  function zoomAt(cx,cy,f){ const nz=clamp(zoom*f,minZoom,maxZoom); const px=(cx-offsetX)/zoom; const py=(cy-offsetY)/zoom; zoom=nz; offsetX=cx-px*zoom; offsetY=cy-py*zoom; applyView(); }
  function contentBounds(){ if(!glyphs.length) return {minX:0,minY:0,maxX:1,maxY:1}; let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity; glyphs.forEach(g=>{minX=Math.min(minX,g.x);minY=Math.min(minY,g.y);maxX=Math.max(maxX,g.x);maxY=Math.max(maxY,g.y);}); return {minX,minY,maxX,maxY}; }
  function fitToView(){ const r=stageRect(); const b=contentBounds(); const pad=40; const w=Math.max(1,b.maxX-b.minX+pad*2); const h=Math.max(1,b.maxY-b.minY+pad*2); const s=Math.min(r.width/w,r.height/h); zoom=clamp(s,minZoom,maxZoom); offsetX=(r.width-(b.maxX-b.minX)*zoom)/2 - b.minX*zoom; offsetY=(r.height-(b.maxY-b.minY)*zoom)/2 - b.minY*zoom; applyView(); }

  stage.addEventListener('wheel', (e)=>{ e.preventDefault(); const rect=stageRect(); const cx=e.clientX-rect.left, cy=e.clientY-rect.top; const factor=Math.pow(1.1,-Math.sign(e.deltaY)); zoomAt(cx,cy,factor); }, {passive:false});
  let spaceDown=false, dragging=false, lastX=0,lastY=0;
  window.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ spaceDown=true; stage.classList.add('panning'); e.preventDefault(); } });
  window.addEventListener('keyup',   (e)=>{ if(e.code==='Space'){ spaceDown=false; stage.classList.remove('panning'); } });
  stage.addEventListener('pointerdown', (e)=>{ if(spaceDown||e.button===1){ dragging=true; stage.classList.add('dragging'); lastX=e.clientX; lastY=e.clientY; stage.setPointerCapture(e.pointerId); } });
  stage.addEventListener('pointermove', (e)=>{ if(!dragging) return; const dx=e.clientX-lastX, dy=e.clientY-lastY; offsetX+=dx; offsetY+=dy; lastX=e.clientX; lastY=e.clientY; applyView(); });
  stage.addEventListener('pointerup',   ()=>{ dragging=false; stage.classList.remove('dragging'); });

  zoomDock.addEventListener('click', (e)=>{ const b=e.target.closest('.zbtn'); if(!b) return; const rect=stageRect(); const cx=rect.width/2, cy=rect.height/2; const t=b.dataset.zoom; if(t==='in') return zoomAt(cx,cy,1.2); if(t==='out') return zoomAt(cx,cy,1/1.2); if(t==='reset'){ zoom=1; offsetX=0; offsetY=0; return applyView(); } if(t==='fit') return fitToView(); });

  // init
  document.documentElement.style.setProperty('--anim-ms','800');
  initPen(); placeCaret(); applyView();
})();
</script>
</body>
</html>