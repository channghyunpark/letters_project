<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Multi-Mode Typing Layout â€” Continue-on-Grid + Zoom/Pan (v0.7.1â€”fullscreen)</title>
<style>
  :root { 
    --bg:#f6f6f6; --fg:#333; --muted:#999; --anim-ms:400;
    --border:#f0f0f0; --border-hover:#ddd; --btn-bg:#f6f6f6; --btn-hover:#f9f9f9;
    --stage-bg:#f6f6f6; --panel-bg:rgba(255,255,255,0.6); --toast-bg:#333; --toast-fg:#f6f6f6;
  }
  [data-theme="dark"] {
    --bg:#1a1a1a; --fg:#e0e0e0; --muted:#888;
    --border:#333; --border-hover:#555; --btn-bg:#2a2a2a; --btn-hover:#3a3a3a;
    --stage-bg:#222; --panel-bg:rgba(26,26,26,0.5); --toast-bg:#f0f0f0; --toast-fg:#333;
  }

  /* === FULLSCREEN LAYOUT === */
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:"Futura",ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,Helvetica,Arial,Apple SD Gothic Neo,"Malgun Gothic",sans-serif}
  .wrap{display:grid;grid-template-rows:1fr;min-height:100dvh}
:lang(ko) { font-family: "Pretendard Variable", "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", sans-serif; }

  .stage{
    position:relative;overflow:hidden;isolation:isolate;
    height:100dvh;
    margin:0;
    border:1px solid var(--border);
    border-radius:0;
    background:var(--stage-bg);
    touch-action:none; /* â† ê¸°ë³¸ ìŠ¤í¬ë¡¤/ì¤Œ ì œìŠ¤ì²˜ ì°¨ë‹¨ */
  }

  .pan-hint {
    font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
    letter-spacing: 0.5px;
  }
  .content{position:absolute;inset:0;transform-origin:0 0}

  .glyph{position:absolute;left:0;top:0;transform:translate3d(0,0,0);transition:transform var(--anim-ms) cubic-bezier(.22,.61,.36,1),opacity var(--anim-ms) ease;will-change:transform;font-size:18px;line-height:1;color:var(--fg);user-select:none;white-space:pre}

  /* Hidden proxy input for direct-on-stage typing */
  .proxyInput{position:fixed;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0;}

  /* Zoom UI */
  .zoomDock{
    position:absolute;right:12px;bottom:12px;display:flex;gap:4px;
    background:var(--btn-bg);border:1px solid var(--border);border-radius:6px;padding:4px;backdrop-filter:blur(4px)
  }
  .zbtn{appearance:none;border:1px solid var(--border);background:var(--btn-bg);color:var(--fg);font-size:11px;padding:4px 6px;border-radius:4px;cursor:pointer;transition:all 0.2s ease}
  .zbtn:hover{border-color:var(--border-hover);background:var(--btn-hover)}
  .stage.panning{cursor:grab}
  .stage.dragging{cursor:grabbing}

  /* Toast */
  .toast{position:fixed;left:50%;bottom:20px;transform:translateX(-50%);background:var(--toast-bg);color:var(--toast-fg);padding:6px 10px;border-radius:6px;font-size:11px;opacity:0;pointer-events:none;transition:opacity .25s ease}
  .toast.show{opacity:.9}

  /* Pan hint */
  .pan-hint{position:absolute;left:12px;bottom:12px;color:var(--muted);font-size:10px;pointer-events:none;user-select:none}

  /* === PANEL (dark-mode only) === */
  .panel{
    position:absolute;
    left:12px; top:12px; z-index:5;
    background:none; border:none; backdrop-filter:none;
    padding:0; margin:0;
  }
  .dark-toggle{
    appearance:none;
    background:none;
    border:1px solid var(--border-hover);
    border-radius:6px;
    color:var(--fg);
    font-size:18px;
    line-height:1;
    cursor:pointer;
    padding:6px 8px;
    transition:background .2s ease,border-color .2s ease,transform .15s ease;
  }
  .dark-toggle:hover{
    background:var(--btn-hover);
    border-color:var(--border);
    transform:scale(1.06);
    color:var(--muted);
  }
  .dark-toggle:active{ transform:scale(0.95); }
</style>
</head>
<body>
<div class="wrap">

  <div class="stage" id="stage" aria-label="ë Œë” ìŠ¤í…Œì´ì§€">
    <div id="content" class="content"></div>

    <!-- Panel: only dark-mode toggle remains -->
    <section class="panel" id="panel">
      <button class="dark-toggle" id="darkToggle" title="Toggle dark mode">ğŸŒ™</button>
      <!-- proxy input stays hidden; keep in DOM -->
      <textarea id="proxyInput" class="proxyInput" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0"></textarea>
    </section>

    <!-- Zoom dock -->
    <div class="zoomDock">
      <button class="zbtn" data-zoom="out" title="Zoom out">âˆ’</button>
      <button class="zbtn" data-zoom="reset" title="Reset to 100%">100%</button>
      <button class="zbtn" data-zoom="in" title="Zoom in">+</button>
      <button class="zbtn" data-zoom="fit" title="Fit to view">Fit</button>
    </div>

    <div class="pan-hint">Tab to change mode â€¢ Drag to pan</div>
  </div>

  <div class="toast" id="toast" hidden></div>
</div>

<script>
(() => {
  const stage   = document.getElementById('stage');
  const content = document.getElementById('content');
  const zoomDock= stage.querySelector('.zoomDock');
  const panel   = document.getElementById('panel');
  const input   = document.getElementById('proxyInput');
  const toast   = document.getElementById('toast');
  const darkToggle = document.getElementById('darkToggle');

  /* === ëª¨ë“œ ëª©ë¡: UI ì—†ì´ ê³ ì • === */
  const MODE_ORDER = ['normal','circle','spiral','wave','tree'];

  function modeLabel(m){ return m[0].toUpperCase()+m.slice(1); }
  function cycleMode(dir){
    const curIdx = MODE_ORDER.indexOf(mode);
    const i = curIdx < 0 ? 0 : curIdx;
    const ni = (i + (dir>0?1:-1) + MODE_ORDER.length) % MODE_ORDER.length;
    const next = MODE_ORDER[ni];
    setMode(next);
    showToast(`Mode: ${modeLabel(next)}`);
  }

  // ===== Mode params =====
  const NORMAL_COLS = 60;
  const NORMAL_STEP_X = 12, NORMAL_STEP_Y = 24;
  const CIRCLE_RADIUS = 120;
  const SPIRAL_A = 3, SPIRAL_B = 0.10;
  const WAVE_A = 60, WAVE_LAMBDA = 200;
  const TREE_SPREAD_BASE = 120, TREE_SPREAD_STEP = 40;
  const TREE_JITTER_X = 8, TREE_JITTER_Y = 5;
  const FIT_PADDING = 40;

  // Tracking
  let TRACK_LATIN = 0;
  let TRACK_HANGUL = 3;
  const TRACK_APPLY_MODES = { normal:true, wave:true, circle:false, spiral:false, tree:false };

  function isHangul(ch){ const c=ch.codePointAt(0);
    return (c>=0x1100&&c<=0x11FF)||(c>=0x3130&&c<=0x318F)||(c>=0xAC00&&c<=0xD7AF); }
  function isLatin(ch){ const c=ch.codePointAt(0);
    return (c>=0x0041&&c<=0x005A)||(c>=0x0061&&c<=0x007A)||(c>=0x0030&&c<=0x0039); }

  // State
  let mode='normal';
  let glyphs=[];
  let prevText='';
  const pen={ x:0,y:0,z:0,i:0,mode:'normal',anchorX:0,anchorY:0,anchorZ:0,_trackX:0 };
  let didAutoFit=false;

  function stageRect(){ return stage.getBoundingClientRect(); }
  function initPen(){ const r=stageRect(); pen.x=r.width/2; pen.y=r.height/2; pen.z=0; pen.anchorX=pen.x; pen.anchorY=pen.y; pen.anchorZ=pen.z; pen.i=0; }

  // Deterministic jitter
  function hash32(x){ let t=x+0x6D2B79F5; t=Math.imul(t ^ (t>>>15), t|1); t^= t + Math.imul(t ^ (t>>>7), t | 61); return ((t ^ (t>>>14))>>>0)/4294967296; }
  function jitter(i, s){ return hash32(i*73856093 + s*19349663) - 0.5; }

  const stepSize=16;
  const Path={
    normal(i){ const cols=NORMAL_COLS; const row=Math.floor(i/cols), col=i%cols;
      return { dx:col*NORMAL_STEP_X, dy:row*NORMAL_STEP_Y, dz:0, rot:0, scale:1 }; },
    circle(i){ const t=i*(Math.PI/16); return { dx:CIRCLE_RADIUS*Math.cos(t), dy:CIRCLE_RADIUS*Math.sin(t), dz:0, rot:t+Math.PI/2, scale:1 }; },
    spiral(i){ const t=i*(Math.PI/10); const r=SPIRAL_A*Math.exp(SPIRAL_B*t)*6; return { dx:r*Math.cos(t), dy:r*Math.sin(t), dz:0, rot:t+Math.PI/2, scale:1 }; },
    wave(i){ const x=i*stepSize; const y=WAVE_A*Math.sin((2*Math.PI/WAVE_LAMBDA)*x); return { dx:x, dy:y, dz:0, rot:0, scale:1 }; },
    tree(i){ const level=Math.floor(Math.log2(i+1));
      const start=(2**level)-1; const j=i-start; const count=2**level;
      const spread=(TREE_SPREAD_BASE+level*TREE_SPREAD_STEP);
      const jx=jitter(i,1), jy=jitter(i,2);
      const x=((j+0.5)/count-0.5)*spread*2 + jx*level*TREE_JITTER_X;
      const y=level*60 + jy*level*TREE_JITTER_Y;
      return { dx:x, dy:y, dz:0, rot:0, scale:1 };
    }
  };
  function getPath(n){ return Path[n]||Path.normal; }

  // Caret
  const caret=document.createElement('div');
  caret.className='glyph'; caret.textContent='â–®'; caret.style.opacity='0.5';
  content.appendChild(caret);
  function placeCaret(){ caret.style.transform=`translate3d(${pen.x}px, ${pen.y}px, ${pen.z}px)`; }

  function placeNextChar(ch){
    if (ch === '\n'){
      pen.anchorY = pen.anchorY + NORMAL_STEP_Y;
      pen.x = pen.anchorX; pen.y = pen.anchorY; pen.z = pen.anchorZ;
      pen.i = 0; pen._trackX = 0; placeCaret(); maybeAutoFit(); return;
    }
    const p=getPath(pen.mode)(pen.i);
    let extraX=0;
    if (TRACK_APPLY_MODES[pen.mode]){
      const t = isHangul(ch) ? TRACK_HANGUL : TRACK_LATIN;
      extraX = pen._trackX || 0;
      pen._trackX = (pen._trackX || 0) + t;
    }
    const x=pen.anchorX + p.dx + extraX, y=pen.anchorY + p.dy, z=pen.anchorZ + p.dz;

    const el=document.createElement('div');
    el.className='glyph';
    el.textContent = (ch===' ' ? ' ' : ch);
    const rotate = (pen.mode==='circle'||pen.mode==='spiral') ? ` rotate(${p.rot}rad)` : '';
    el.style.transform = `translate3d(${x}px, ${y}px, ${z}px)` + rotate;

    content.appendChild(el);
    glyphs.push({el,ch,x,y,z});

    pen.x=x; pen.y=y; pen.z=z; pen.i+=1; placeCaret(); maybeAutoFit();
  }

  function backspaceOne(){
    if(!glyphs.length) return;
    const g=glyphs.pop(); g.el.remove();
    const last=glyphs[glyphs.length-1];
    if(last){ pen.x=last.x; pen.y=last.y; pen.z=last.z; } else { initPen(); }
    pen.i=Math.max(0,pen.i-1); placeCaret();
  }

  function maybeAutoFit(){ if(!didAutoFit && glyphs.length===1){ fitToView(); didAutoFit=true; } }

  // Strict append-only
  const STRICT_APPEND=true;
  let composing=false;
  input.addEventListener('compositionstart', ()=> composing=true);
  input.addEventListener('compositionend',  ()=>{ composing=false; processInput(); });
  input.addEventListener('input',           ()=>{ if(!composing) processInput(); });

  function showToast(msg){
    if (!toast) return;
    toast.textContent=msg; toast.hidden=false; toast.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t=setTimeout(()=>{ toast.classList.remove('show'); toast.hidden=true; }, 1200);
  }

  function processInput(){
    const cur=input.value; const selStart=input.selectionStart; const isTail=(selStart===cur.length);
    if(cur.startsWith(prevText)){ const appended=cur.slice(prevText.length); for(const ch of appended) placeNextChar(ch); prevText=cur; return; }
    if(prevText.startsWith(cur) && isTail){ const n=prevText.length-cur.length; for(let i=0;i<n;i++) backspaceOne(); prevText=cur; return; }
    if(STRICT_APPEND){
      input.value=prevText; input.setSelectionRange(prevText.length,prevText.length);
      showToast('ì¤‘ê°„ í¸ì§‘ì€ ì´ì–´ì“°ê¸° ëª¨ë“œì—ì„œ í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.'); return;
    }
    content.querySelectorAll('.glyph').forEach(n=>n.remove()); glyphs=[]; initPen(); placeCaret();
    for(const ch of cur) placeNextChar(ch); prevText=cur;
  }

  // Mode switch (Tab ì „ìš©)
  function setMode(newMode){
    mode=newMode;
    pen.mode=mode; pen.anchorX=pen.x; pen.anchorY=pen.y; pen.anchorZ=pen.z; pen.i=0; pen._trackX=0; placeCaret();
    focusToTextarea();
  }

  function focusToTextarea(){
    requestAnimationFrame(()=>{
      input.focus({ preventScroll:true });
      const len=input.value.length; try{ input.setSelectionRange(len,len); }catch(_){}
    });
  }

  // Dark mode
  function toggleDarkMode(){
    const isDark=document.documentElement.getAttribute('data-theme')==='dark';
    const next=isDark?'light':'dark';
    document.documentElement.setAttribute('data-theme', next);
    darkToggle.textContent = isDark ? 'ğŸŒ™' : 'â˜€ï¸';
    localStorage.setItem('theme', next);
  }
  function initDarkMode(){
    const saved=localStorage.getItem('theme')||'light';
    document.documentElement.setAttribute('data-theme', saved);
    darkToggle.textContent = saved==='dark' ? 'â˜€ï¸' : 'ğŸŒ™';
  }

  // íŒ¨ë„(ë‹¤í¬ í† ê¸€ë§Œ ì¡´ì¬)
  panel.addEventListener('pointerdown', (e)=> e.stopPropagation());
  panel.addEventListener('pointerup',   (e)=> e.stopPropagation());
  panel.addEventListener('click',       (e)=> e.stopPropagation());
  darkToggle.addEventListener('click', toggleDarkMode);

  // ===== Keyboard: Tab cycle (SpaceëŠ” ì„ íƒ ë³´ì¡°ê²½ë¡œë¡œ ìœ ì§€í•˜ì§€ ì•ŠìŒ) =====
  window.addEventListener('keydown', (e)=>{ 
    if(e.key==='Tab'){
      if (typeof composing !== 'undefined' && composing) return;
      e.preventDefault();
      cycleMode(e.shiftKey ? -1 : 1);
    }
  });

  // ===== Zoom & Pan =====
  let zoom=1, offsetX=0, offsetY=0; const minZoom=0.3, maxZoom=4;
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function updateZoomDisplay(){ const btn=zoomDock.querySelector('[data-zoom="reset"]'); if(btn) btn.textContent=Math.round(zoom*100)+'%'; }
  function applyView(){ content.style.transform=`translate(${offsetX}px, ${offsetY}px) scale(${zoom})`; updateZoomDisplay(); }
  function zoomAt(cx,cy,f){ const nz=clamp(zoom*f,minZoom,maxZoom); const px=(cx-offsetX)/zoom; const py=(cy-offsetY)/zoom; zoom=nz; offsetX=cx-px*zoom; offsetY=cy-py*zoom; applyView(); }
  function contentBounds(){ if(!glyphs.length) return {minX:0,minY:0,maxX:1,maxY:1}; let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity; glyphs.forEach(g=>{minX=Math.min(minX,g.x);minY=Math.min(minY,g.y);maxX=Math.max(maxX,g.x);maxY=Math.max(maxY,g.y);}); return {minX,minY,maxX,maxY}; }
  function fitToView(){ const r=stageRect(); const b=contentBounds(); const w=Math.max(1,b.maxX-b.minX+FIT_PADDING*2); const h=Math.max(1,b.maxY-b.minY+FIT_PADDING*2); const s=Math.min(r.width/w,r.height/h); zoom=clamp(s,minZoom,maxZoom); offsetX=(r.width-(b.maxX-b.minX)*zoom)/2 - b.minX*zoom; offsetY=(r.height-(b.maxY-b.minY)*zoom)/2 - b.minY*zoom; applyView(); }

  function toContentCoords(clientX, clientY){
    const r=stageRect(); const sx=clientX-r.left; const sy=clientY-r.top;
    return { x:(sx-offsetX)/zoom, y:(sy-offsetY)/zoom };
  }

  // íœ  ì¤Œ
  let lastWheel=0;
  stage.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const now=performance.now(); if(now-lastWheel<16) return; lastWheel=now;
    const rect=stageRect(); const cx=e.clientX-rect.left, cy=e.clientY-rect.top;
    const factor=Math.pow(1.1,-Math.sign(e.deltaY)); zoomAt(cx,cy,factor); updateZoomDisplay();
  }, {passive:false});

  // ===== Drag to pan (Space ì—†ì´) + Click-to-type ë³´í˜¸ =====
  let panCandidate=false, dragging=false, lastX=0,lastY=0, downX=0, downY=0;
  const DRAG_THRESHOLD=4;
  let restoreFocusAfterDrag=false;

  function isUIHit(target){
    return !!(target.closest('.panel') || target.closest('.zoomDock'));
  }

  stage.addEventListener('pointerdown', (e)=>{
    if (isUIHit(e.target)) return;      // UI ìœ„ì—ì„œëŠ” ì œìŠ¤ì²˜ ì‹œì‘ ê¸ˆì§€
    panCandidate=true; dragging=false;
    downX=lastX=e.clientX; downY=lastY=e.clientY;
    stage.setPointerCapture(e.pointerId);
    e.preventDefault();                 // ëª¨ë°”ì¼ ìŠ¤í¬ë¡¤/í…ìŠ¤íŠ¸ ì„ íƒ ë°©ì§€
  });

  stage.addEventListener('pointermove', (e)=>{
    if(!panCandidate && !dragging) return;
    const dx=e.clientX-lastX, dy=e.clientY-lastY;
    const movedTotal=Math.hypot(e.clientX-downX, e.clientY-downY);

    if(!dragging){
      if(movedTotal>DRAG_THRESHOLD){
        dragging=true;
        stage.classList.add('dragging');
        restoreFocusAfterDrag=true;
      } else {
        return; // ì•„ì§ í´ë¦­ íŒë‹¨ êµ¬ê°„
      }
    }

    offsetX+=dx; offsetY+=dy;
    lastX=e.clientX; lastY=e.clientY;
    applyView();
    e.preventDefault();
  });

  function endPointer(e){
    if(dragging){
      dragging=false; stage.classList.remove('dragging');
      if (restoreFocusAfterDrag){ restoreFocusAfterDrag=false; focusToTextarea(); }
      panCandidate=false;
      return; // íŒ¨ë‹ ì œìŠ¤ì²˜ì˜€ë‹¤ë©´ ì»¤ì„œ ì´ë™ ì—†ìŒ
    }

    if(!panCandidate) return;
    panCandidate=false;

    // í´ë¦­-íˆ¬-íƒ€ì… (threshold ì´í•˜ë¡œ ì›€ì§ì˜€ì„ ë•Œë§Œ)
    const moved=Math.hypot(e.clientX-downX, e.clientY-downY);
    if(moved<=DRAG_THRESHOLD && e.button!==1){
      const {x,y}=toContentCoords(e.clientX, e.clientY);
      pen.anchorX=x; pen.anchorY=y; pen.anchorZ=0; 
      pen.x=x; pen.y=y; pen.z=0; pen.i=0; pen._trackX=0;
      placeCaret(); focusToTextarea();
    }
  }

  stage.addEventListener('pointerup', endPointer);
  stage.addEventListener('pointercancel', endPointer);

  // Keep typing flowing to proxy input even if stage has focus
  stage.addEventListener('keydown', (e)=>{
    if(document.activeElement!==input){ focusToTextarea(); }
  });

  // init
  document.documentElement.style.setProperty('--anim-ms','800');
  initDarkMode();
  initPen(); placeCaret(); applyView();

  // On resize, keep fit if nothing typed yet; else maintain current view
  window.addEventListener('resize', ()=>{ if(!glyphs.length){ applyView(); } });
})();
</script>
</body>
</html>
